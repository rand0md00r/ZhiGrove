import{_ as n,c as l,o as h,ag as a,j as i,a as e,t as r}from"./chunks/framework.CQuhCYrb.js";const y=JSON.parse('{"title":"论文理论包装方案","description":"","frontmatter":{"title":"论文理论包装方案","created":"2025-09-07 17:02","updated":"2025-09-07T00:00:00.000Z","origin":"week-35","type":"idea","status":"draft","tags":[],"links":[]},"headers":[],"relativePath":"30-ideas/2025/9月/250829-0735-论文理论包装方案.md","filePath":"30-ideas/2025/9月/250829-0735-论文理论包装方案.md"}'),p={name:"30-ideas/2025/9月/250829-0735-论文理论包装方案.md"};function k(t,s,o,g,d,E){return h(),l("div",null,[s[2]||(s[2]=a('<h2 id="问题" tabindex="-1">问题 <a class="header-anchor" href="#问题" aria-label="Permalink to &quot;问题&quot;">​</a></h2><ul><li></li></ul><h2 id="原因-洞察" tabindex="-1">原因/洞察 <a class="header-anchor" href="#原因-洞察" aria-label="Permalink to &quot;原因/洞察&quot;">​</a></h2><ul><li></li></ul><h2 id="下一步行动" tabindex="-1">下一步行动 <a class="header-anchor" href="#下一步行动" aria-label="Permalink to &quot;下一步行动&quot;">​</a></h2><ul><li>[ ]</li><li>[ ]</li></ul><h2 id="raw-notes" tabindex="-1">Raw Notes <a class="header-anchor" href="#raw-notes" aria-label="Permalink to &quot;Raw Notes&quot;">​</a></h2><p>很可以！把你的方法放到<strong>最优传输（OT）<strong>框架下，论文的“理论味道”会更足，而且许多设计（q_vl 前缀、MoE、KL、高斯潜空间、Flow-Matching）都能一一对上号。下面给你一份</strong>OT 视角的包装思路大纲</strong>，可直接扩写进论文的方法/理论章节；末尾给两段可落地到训练代码里的正则项示例。</p><h1 id="ot-视角总纲-一句话" tabindex="-1">OT 视角总纲（一句话） <a class="header-anchor" href="#ot-视角总纲-一句话" aria-label="Permalink to &quot;OT 视角总纲（一句话）&quot;">​</a></h1><p>把 <code>z0∼μ0</code>（经 KL 约束到 <strong>N(0,I)</strong> 的<strong>源分布</strong>）通过条件可测的<strong>传输图</strong> $T_S$（由前缀 $S!=!q_{vl}$ 与序列 $[q_{vl}!|!q_m]$ 决定）送到目标图像潜空间分布 $\\nu_S$（VAE posterior），并用 <strong>动态 OT（Benamou–Brenier）</strong> 的速度场参数化实现：$\\dot z_t=v_\\theta(z_t,t,S)$。Flow-Matching 就是在拟合这个速度场；若额外最小化<strong>动能</strong>，则逼近 $W_2$-最优传输。</p><hr><h2 id="_1-条件-ot-前缀当-条件-kl-保证-ot-可解" tabindex="-1">1) 条件 OT：前缀当“条件”，KL 保证 OT 可解 <a class="header-anchor" href="#_1-条件-ot-前缀当-条件-kl-保证-ot-可解" aria-label="Permalink to &quot;1) 条件 OT：前缀当“条件”，KL 保证 OT 可解&quot;">​</a></h2><ul><li><strong>条件变量</strong>：令 $S=\\text{q}_{vl}$（可看成从 $(X_t,X_v)$ 抽取的“前缀充分统计”）。</li><li><strong>源/靶分布</strong>：$\\mu_0\\approx\\mathcal N(0,I)$（由 KL 正则驱动）、$\\nu_S$ 为 VAE 给出的图像潜空间后验。</li><li><strong>Monge 问题（逐条件）</strong>：对每个 $S$，学习 $T_S:\\mathbb R^d\\to\\mathbb R^d$，使 $T_{S#}\\mu_0=\\nu_S$ 且最小化 $\\int|x-T_S(x)|^2,d\\mu_0$。$\\mu_0$ 绝对连续 ⇒ <strong>Brenier 定理</strong>：最优 $T_S=\\nabla\\phi_S$ 为<strong>凸势函数梯度</strong>（给“可解释的方向”）。</li><li><strong>你做的事</strong>：用速度场 $v_\\theta$ 的常微分方程 $\\dot z_t=v_\\theta(z_t,t,S)$ 实现 $T_S$；把 KL 加到 $\\mu_0$ 上就是在满足 Brenier 条件（源绝对连续、几何良性）。</li></ul><hr><h2 id="_2-动态-ot-flow-matching-≈-学-bb-速度场" tabindex="-1">2) 动态 OT：Flow-Matching ≈ 学 BB 速度场 <a class="header-anchor" href="#_2-动态-ot-flow-matching-≈-学-bb-速度场" aria-label="Permalink to &quot;2) 动态 OT：Flow-Matching ≈ 学 BB 速度场&quot;">​</a></h2>',15)),i("ul",null,[i("li",null,[s[0]||(s[0]=i("p",null,[i("strong",null,"Benamou–Brenier"),e("：")],-1)),i("p",null,"$$ W_2^2(\\mu_0,\\nu_S)=\\min_"+r(t.p_t,t.v_t)+" \\int_0^1!\\mathbb E_{z\\sim p_t}!\\big[|v_t(z)|^2\\big],dt\\quad \\text{s.t. }\\partial_t p_t+\\nabla!\\cdot(p_t v_t)=0,\\ p_0=\\mu_0,\\ p_1=\\nu_S. $$",1)]),s[1]||(s[1]=a("<li><p><strong>Flow-Matching</strong>：用可选插值 $p_t$（你当前用的线性插值 $z_t=\\alpha(t)z_1+\\beta(t)z_0$）给出“真速度” $\\dot z_t$，最小化 $\\mathbb E|\\ v_\\theta(z_t,t,S)-\\dot z_t\\ |^2$。</p></li><li><p><strong>OT 化的关键</strong>：再加一个<strong>动能正则</strong> $\\displaystyle \\lambda_{\\text{KE}}!\\int_0^1!\\mathbb E|v_\\theta(z_t,t,S)|^2 dt$， 就在把学到的路径往 <strong>BB 最小作用量</strong>靠拢；若插值选为<strong>位移插值（displacement interpolation）</strong>，该最小解即 $W_2$-<strong>测地</strong>。</p></li><li><p><strong>实践可宣称</strong>：Flow-Matching + 动能正则 → <strong>近似动态 OT</strong>；实验可用 Sinkhorn 估计的 $W_2$（批次上）去对比“动作量差距”。</p></li>",3))]),s[3]||(s[3]=a(`<hr><h2 id="_3-moe-分片-monge-映射-半离散-ot-直觉" tabindex="-1">3) MoE = 分片 Monge 映射（半离散 OT 直觉） <a class="header-anchor" href="#_3-moe-分片-monge-映射-半离散-ot-直觉" aria-label="Permalink to &quot;3) MoE = 分片 Monge 映射（半离散 OT 直觉）&quot;">​</a></h2><ul><li><strong>OT 结构</strong>：最优传输映射 $T_S$ 是<strong>梯度场</strong>；在“半离散”情形（目标为离散/混合），Brenier 势是<strong>分段线性凸</strong>，映射在“Laguerre cells”内近似仿射。</li><li><strong>你方案的解释</strong>：Switch-MoE（Top-1 路由）≈<strong>把空间按路由划分为多个“传输胞腔”</strong>，每位专家学一个<strong>局部的近仿射传输</strong>；这与半离散 OT 的<strong>幂图划分</strong>形态高度契合。</li><li><strong>论文可主张</strong>：MoE 为“分片 Monge 图”的逼近器；路由负载均衡与噪声门控减少“错误分片”（误配项），提升条件 OT 拟合。</li></ul><hr><h2 id="_4-解耦掩码的-ot-含义" tabindex="-1">4) 解耦掩码的 OT 含义 <a class="header-anchor" href="#_4-解耦掩码的-ot-含义" aria-label="Permalink to &quot;4) 解耦掩码的 OT 含义&quot;">​</a></h2><ul><li><strong>解耦（块稀疏因果注意）</strong>：让 $Q_v$ 在构建 $S$ 前<strong>不直接见到</strong>文本，减少“错误条件”的泄漏；</li><li><strong>OT 角度</strong>：更干净的条件 $S$ ⇒ $\\nu_S$ 的统计稳定 ⇒ 学到的 $T_S$ 在“同一条件族”下更一致（对 $S$ 的李普希茨）。</li><li><strong>实验</strong>：显示“泄漏度”↓（CKA/HSIC）、“条件平滑性”↑（$T_S$ 对 $S$ 的 Lipschitz 估计↓）与更小的 Sinkhorn $W_2$。</li></ul><hr><h2 id="_5-论文里可加的-ot-友好-正则与指标" tabindex="-1">5) 论文里可加的“OT 友好”正则与指标 <a class="header-anchor" href="#_5-论文里可加的-ot-友好-正则与指标" aria-label="Permalink to &quot;5) 论文里可加的“OT 友好”正则与指标&quot;">​</a></h2><p><strong>正则（建议进损失）：</strong></p><ol><li><strong>动能（BB action）</strong> $\\displaystyle \\mathcal L_{\\text{KE}}=\\lambda_{\\text{KE}}\\cdot\\mathbb E_{t},|v_\\theta(z_t,t,S)|_2^2$。</li><li><strong>无旋（Irrotational）/ Brenier 先验</strong>：鼓励 $v\\approx\\nabla\\psi$， $\\displaystyle \\mathcal L_{\\text{curl}}=\\lambda_{\\text{curl}}\\cdot \\mathbb E|J_v - J_v^\\top|_F^2$ （$J_v$ 为对 $z_t$ 的雅可比），把场拉向<strong>梯度场</strong>（OT 需要）。</li><li><strong>源高斯化</strong>（你已有 KL）：保证 $\\mu_0$ 绝对连续，利于 Brenier 唯一性。</li></ol><p><strong>指标（实验图表）：</strong></p><ul><li><strong>批次 Sinkhorn $W_2$</strong>：估计 $\\hat W_2(\\mu_0!\\xrightarrow{T_S}!\\nu_S)$；对比是否加 $\\mathcal L_{\\text{KE}}$。</li><li><strong>动作量差距</strong>：$\\int|v_\\theta|^2dt$ 与 Sinkhorn $\\hat W_2^2$ 的差。</li><li><strong>无旋度</strong>：$|J_v - J_v^\\top|_F$ 曲线。</li><li><strong>路由专化</strong>：专家利用率/Gini/熵；与 $W_2$ 的相关性。</li></ul><hr><h2 id="_6-可选-更强理论味-的头部替换-附录可提" tabindex="-1">6) 可选“更强理论味”的头部替换（附录可提） <a class="header-anchor" href="#_6-可选-更强理论味-的头部替换-附录可提" aria-label="Permalink to &quot;6) 可选“更强理论味”的头部替换（附录可提）&quot;">​</a></h2><ul><li>若想给“<strong>Monge-Brenier 保证</strong>”，可把 <strong>DeepSets→Conv 头</strong>替换为 <strong>ICNN 势函数</strong> $\\phi_S$，并输出 $T_S=\\nabla\\phi_S$。实践可先不换，只在附录说明“可切换到 ICNN 以获得单调/凸性保证”。</li></ul><hr><h2 id="_7-两段可直接接入的-ot-正则代码-pytorch" tabindex="-1">7) 两段可直接接入的 OT 正则代码（PyTorch） <a class="header-anchor" href="#_7-两段可直接接入的-ot-正则代码-pytorch" aria-label="Permalink to &quot;7) 两段可直接接入的 OT 正则代码（PyTorch）&quot;">​</a></h2><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 1) 动能（Benamou–Brenier action）正则</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kinetic_energy_reg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(v_pred):</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # v_pred: (B, C, H, W) or (B, D)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (v_pred</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">**</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).mean()</span></span></code></pre></div><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 2) 无旋/梯度场先验（对 z 的雅可比反对称项惩罚）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> curl_free_reg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(v_pred, z_t):</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;&quot;&quot;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    v_pred, z_t 形状先展平到 (B, D)</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    计算 J = dv/dz 的反对称部分范数 ||J - J^T||_F^2</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    警告：会增大显存/开销，可在小批上启用</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;&quot;&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    B </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> z_t.shape[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    v </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> v_pred.view(B, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    z </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> z_t.view(B, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    J_cols </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> []</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> d </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> range</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(v.shape[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]):  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 逐输出维</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        grad_vd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> torch.autograd.grad(v[:, d].sum(), z, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">create_graph</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">True</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">retain_graph</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">True</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        J_cols.append(grad_vd.unsqueeze(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># (B, D, 1)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    J </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> torch.cat(J_cols, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">dim</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)            </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># (B, D, D)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    anti </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> J </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> J.transpose(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (anti</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">**</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).mean()</span></span></code></pre></div><p>训练时合到总损失：</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">loss_fm </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fm_loss(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">loss_ke </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> lambda_ke   </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> kinetic_energy_reg(v_pred)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">loss_cu </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> lambda_curl </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> curl_free_reg(v_pred, z_t)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">loss    </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> loss_fm </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> loss_ke </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> loss_cu </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> loss_klz0 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> loss_moe </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ...</span></span></code></pre></div><hr><h3 id="小结-写进论文的一段话" tabindex="-1">小结（写进论文的一段话） <a class="header-anchor" href="#小结-写进论文的一段话" aria-label="Permalink to &quot;小结（写进论文的一段话）&quot;">​</a></h3><blockquote><p><em>We recast our method as learning conditional OT maps. Given a Gaussianized source $\\mu_0$ (enforced via KL) and a VAE posterior $\\nu_S$ conditioned on a prefix $S$, we parameterize a time-dependent velocity field $v_\\theta(\\cdot,t,S)$ whose flow transports $\\mu_0$ to $\\nu_S$. Flow-Matching fits this field, while a kinetic-energy regularizer drives the path toward the Benamou–Brenier minimal-action solution, i.e., the $W_2$ geodesic. Our Switch-MoE realizes a piecewise approximation to the Monge map, consistent with the polyhedral structure of semi-discrete OT. The block-sparse causal masking reduces cross-modal leakage, stabilizing the conditional family \${\\nu_S}$.</em></p></blockquote>`,24))])}const c=n(p,[["render",k]]);export{y as __pageData,c as default};
